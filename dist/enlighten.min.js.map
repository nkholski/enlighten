{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///(webpack)/buildin/global.js","webpack:///./app/index.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","g","this","Function","eval","e","window","global","Enlighten","_class","config","arguments","length","undefined","_classCallCheck","language","useLocalStorage","api","exclude","words","quedTasks","updated","matches","extraWords","_getWords","enlightenPopup","_popupPassthrough","bind","modal","_addModalHTML","_createClass","key","_this","keys","forEach","word","_isReady","id","push","_updateMatches","find","el","sourceRef","targetRef","append","source","_getElement","innerHTML","target","list","_makeWordList","prepend","linked","_makeIndex","multiple","method","parseText","text","_this2","ids","_getIdsFromText","found","match","indexOf","cleanStart","substring","cleanEnd","compare","replace","rx","RegExp","test","matchedWord","p1","toLowerCase","fullMatch","keyWord","show","wordObject","_this3","pattern","_this4","bullets","_alphabetizeIds","getWord","title","_this5","html","_defaultPopup","explaination","document","getElementById","style","display","getElementsByTagName","element","getElementsByClassName","concat","sort","a","b","_this6","localeCompare","_this7","localStorage","getItem","JSON","parse","_ajaxGet","then","response","data","setItem","stringify","_executeQue","_len","args","Array","_key","_addToQue","_len2","_key2","shift","_this8","task","apply","_toConsumableArray","_this9","Promise","resolve","reject","url","req","XMLHttpRequest","open","onload","status","Error","statusText","onerror","send","modalEl","createElement","setAttribute","appendChild","onclick","event"],"mappings":"aACA,IAAAA,KAGA,SAAAC,EAAAC,GAGA,GAAAF,EAAAE,GACA,OAAAF,EAAAE,GAAAC,QAGA,IAAAC,EAAAJ,EAAAE,IACAG,EAAAH,EACAI,GAAA,EACAH,YAUA,OANAI,EAAAL,GAAAM,KAAAJ,EAAAD,QAAAC,IAAAD,QAAAF,GAGAG,EAAAE,GAAA,EAGAF,EAAAD,QAKAF,EAAAQ,EAAAF,EAGAN,EAAAS,EAAAV,EAGAC,EAAAU,EAAA,SAAAR,EAAAS,EAAAC,GACAZ,EAAAa,EAAAX,EAAAS,IACAG,OAAAC,eAAAb,EAAAS,GACAK,cAAA,EACAC,YAAA,EACAC,IAAAN,KAMAZ,EAAAmB,EAAA,SAAAjB,GACAY,OAAAC,eAAAb,EAAA,cAAiDkB,OAAA,KAIjDpB,EAAAqB,EAAA,SAAAlB,GACA,IAAAS,EAAAT,KAAAmB,WACA,WAA2B,OAAAnB,EAAA,SAC3B,WAAiC,OAAAA,GAEjC,OADAH,EAAAU,EAAAE,EAAA,IAAAA,GACAA,GAIAZ,EAAAa,EAAA,SAAAU,EAAAC,GAAsD,OAAAV,OAAAW,UAAAC,eAAAnB,KAAAgB,EAAAC,IAGtDxB,EAAA2B,EAAA,GAIA3B,IAAA4B,EAAA,mBCnEA,IAAAC,EAGAA,EAAA,WACA,OAAAC,KADA,GAIA,IAEAD,KAAAE,SAAA,cAAAA,KAAA,EAAAC,MAAA,QACC,MAAAC,GAED,iBAAAC,SAAAL,EAAAK,QAOA/B,EAAAD,QAAA2B,yRCFAM,EAAOC,UAAP,WAYI,SAAAC,IAAyB,IAAbC,EAAaC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,mGAAAG,CAAAZ,KAAAO,GAErBP,KAAKa,SAAWL,EAAOZ,eAAe,YAAcY,EAAOK,SAAW,KACtEb,KAAKc,iBAAkBN,EAAOZ,eAAe,oBAAqBY,EAAOM,gBACzEd,KAAKe,IAAMP,EAAOZ,eAAe,OAASY,EAAOO,IAAM,sDACvDf,KAAKgB,WACLhB,KAAKiB,SACLjB,KAAKkB,aACLlB,KAAKmB,SAAU,EACfnB,KAAKoB,WAELpB,KAAKqB,cACLrB,KAAKsB,YACLlB,OAAOmB,eAAiBvB,KAAKwB,kBAAkBC,KAAKzB,MAEpDA,KAAK0B,MAAQ1B,KAAK2B,gBA3B1B,OAAAC,EAAArB,IAAAsB,IAAA,SAAAvC,MAAA,SAwCWkB,GAAQ,IAAAsB,EAAA9B,KACXhB,OAAO+C,KAAKvB,GAAQwB,QAChB,SAACH,GACG,OAAQA,GACJ,IAAK,WACL,IAAK,UACDC,EAAKD,GAAOrB,EAAOqB,SA9C3CA,IAAA,UAAAvC,MAAA,SA4DY2C,GACCjC,KAAKkC,SAAS,UAAWD,KAG9BA,EAAKE,IAAMnC,KAAKqB,WAAWX,OAAS,EACpCV,KAAKqB,WAAWe,KAAKH,GACrBjC,KAAKqC,qBAlEbR,IAAA,UAAAvC,MAAA,SA6EY6C,GACJ,OAAIA,EAAK,EACEnC,KAAKqB,WAAWiB,KAAK,SAACC,GACzB,OAAOA,EAAGJ,KAAOA,IAGdnC,KAAKiB,MAAMqB,KAAK,SAACC,GACpB,OAAOA,EAAGJ,KAAOA,OApFjCN,IAAA,iBAAAvC,MAAA,WAmGoE,IAAjDkD,EAAiD/B,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAArC,GAAIgC,EAAiChC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAArB,KAAMiC,IAAejC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,KAAAA,UAAA,GAC5D,GAAKT,KAAKkC,SAAS,iBAAkBM,EAAWC,EAAWC,GAA3D,CAGAD,EAAYA,GAAwBD,EACpC,IAAIG,EAASH,EAAU9B,OAAS,EAAIV,KAAK4C,YAAYJ,GAAWK,UAAY,GACxEC,EAAS9C,KAAK4C,YAAYH,GAC1BM,EAAO/C,KAAKgD,cAAcL,GAC1BD,EACAI,EAAOD,WAAaE,EAEpBD,EAAOD,UAAYE,MA9G/BlB,IAAA,cAAAvC,MAAA,SA4HgBkD,EAAWC,GAA0C,IAA/BQ,IAA+BxC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,KAAAA,UAAA,GAAfyC,IAAezC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,KAAAA,UAAA,GAC7D,GAAKT,KAAKkC,SAAS,cAAeM,EAAWC,EAAWQ,EAASC,GAAjE,CAGAT,EAAYA,GAAwBD,EACpC,IAAIG,EAASH,EAAU9B,OAAS,EAAIV,KAAK4C,YAAYJ,GAAWK,UAAY,GACxEC,EAAS9C,KAAK4C,YAAYH,GAC1BM,EAAO/C,KAAKmD,WAAWR,EAAQO,GAE/BJ,EAAOD,UADPI,EACmBF,EAAOD,EAAOD,UAEdE,MAvI/BlB,IAAA,eAAAvC,MAAA,SAoJiBkD,GAA2C,IAAhCY,IAAgC3C,UAAAC,OAAA,QAAAC,IAAAF,UAAA,KAAAA,UAAA,GAAf4C,EAAe5C,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAN,KAC9C,GAAKT,KAAKkC,SAAS,eAAgBM,EAAWY,EAAUC,GAAxD,CAGA,IAAIV,EAAS3C,KAAK4C,YAAYJ,GAC9BG,EAAOE,UAAY7C,KAAKsD,UAAUX,EAAOE,UAAWO,EAAUC,OAzJtExB,IAAA,YAAAvC,MAAA,SAsKciE,GAAiD,IAAAC,EAAAxD,KAA3CoD,IAA2C3C,UAAAC,OAAA,QAAAC,IAAAF,UAAA,KAAAA,UAAA,GAA1B4C,EAA0B5C,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAjB,gBAClCgD,EAAMzD,KAAK0D,gBAAgBH,GAC3BI,KA2GJ,OA1GAP,GAAwB,IAAbA,EAEXC,EAAoB,OAAXA,EAAkB,gBAAkBA,EAC7CrD,KAAKoB,QAAQY,QACT,SAAC4B,GACG,IAAoC,IAAhCH,EAAII,QAAQD,EAAM3B,KAAKE,IAA3B,CAGA,IAAI2B,EAA6C,MAAhCF,EAAMA,MAAMG,UAAU,EAAG,GACtCC,EAA2D,MAAhDJ,EAAMA,MAAMG,UAAUH,EAAMA,MAAMlD,OAAO,GACpDuD,EAAUL,EAAMA,MAAMM,QAAQ,MAAO,IAMrCC,EAAK,IAAIC,OALC,oDAEJH,EAAU,kBACAA,EAAU,mBAED,MAGzBE,EAAGE,KAAKd,KACRA,EAAOA,EAAKW,QAAQC,EAAI,SAAUG,EAAaC,GAC3C,OAAInB,IAA8C,IAAlCO,EAAME,QAAQD,EAAM3B,KAAKE,IAcrC2B,GAA6D,IAA/CQ,EAAYE,cAAcX,QAAQI,GACzCK,EAGPN,GAAYM,EAAYE,cAAcX,QAAQI,KAAaK,EAAY5D,OAASuD,EAAQvD,OACjF4D,GAEXX,EAAMvB,KAAKwB,EAAM3B,KAAKE,IAEP,UAAXkB,EACOkB,EAAK,yBAA2BX,EAAM3B,KAAKE,GAAK,iCAAmCoC,EAAK,OAASD,EAEjGC,EAAK,8BAAgCX,EAAM3B,KAAKE,GAAK,KAAQkB,EAAS,oCAAsCkB,EAAK,OAASD,GAzB1HA,QAmC3Bf,EAAOA,EAAKW,QAAQ,iEAAkE,SAACO,EAAWC,EAASC,GACvG,IAAIhB,GAAQ,EACRiB,SAaJ,OAXApB,EAAKpC,QAAQY,QACT,SAAC4B,GACG,IAAID,EAGJ,OAAIC,EAAMA,QAAUc,EAAQF,eACxBI,EAAahB,OACbD,GAAQ,SAFZ,IAMHA,EAGU,UAAXN,EACOqB,EAAU,yBAA2BE,EAAW3C,KAAKE,GAAK,iCAAmCwC,EAAO,OAASF,EAE7GC,EAAU,8BAAgCE,EAAW3C,KAAKE,GAAK,KAAQkB,EAAS,oCAAsCsB,EAAO,OAASF,EALtIA,OAlPvB5C,IAAA,kBAAAvC,MAAA,WA+R+B,IAAAuF,EAAA7E,KAAXuD,EAAW9C,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAJ,GACfgD,KA2BJ,OAvBAF,GADAA,GADAA,EAAOA,EAAKW,QAAQ,kCAAmC,KAC3CA,QAAQ,sCAAuC,OAC/CA,QAAQ,UAAW,IAE/BlE,KAAKoB,QAAQY,QAAQ,SAAC4B,GAClB,IAAoC,IAAhCH,EAAII,QAAQD,EAAM3B,KAAKE,MAAuD,IAAzC0C,EAAK7D,QAAQ6C,QAAQD,EAAM3B,KAAKE,IAGzE,GAAoB,IAAhBoB,EAAK7C,OAAT,CAIA,IAAIoD,EAA6C,MAAhCF,EAAMA,MAAMG,UAAU,EAAG,GACtCC,EAA2D,MAAhDJ,EAAMA,MAAMG,UAAUH,EAAMA,MAAMlD,OAAO,GACpDuD,EAAUL,EAAMA,MAAMM,QAAQ,MAAO,IAErCY,EAAUhB,EAAa,mBAAqB,GAChDgB,GAAWb,EACXa,GAAWd,EAAW,mBAAqB,GACtC,IAAII,OAAOU,EAAS,KAClBT,KAAKd,IACRE,EAAIrB,KAAKwB,EAAM3B,KAAKE,SAZpBsB,EAAIrB,KAAKwB,EAAM3B,KAAKE,MAgBrBsB,KA3Tf5B,IAAA,aAAAvC,MAAA,SAsUeiE,GAAqB,IAAAwB,EAAA/E,KAAfkD,IAAezC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,KAAAA,UAAA,GAExBuE,EAAU,GAUd,OAXUhF,KAAKiF,gBAAgBjF,KAAK0D,gBAAgBH,IAEhDvB,QACA,SAACG,GAEO6C,GADA9B,EACA8B,6BAAwC7C,EAAxC,KAA+C4C,EAAKG,QAAQ/C,GAAIgD,MAAhE,cAEAH,OAAkBD,EAAKG,QAAQ/C,GAAIgD,MAAnC,YAIZ,kEAGIH,EAHJ,yCAlVRnD,IAAA,gBAAAvC,MAAA,WAmW4C,IAAA8F,EAAApF,KAA1BuD,EAA0B9C,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAnB,GAAIyC,IAAezC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,KAAAA,UAAA,GAEhC4E,EAAO,GAaX,OAdUrF,KAAKiF,gBAAgBjF,KAAK0D,gBAAgBH,IAEhDvB,QACA,SAACG,GACG,IAAIF,EAAOmD,EAAKF,QAAQ/C,GACxBkD,GAAQ,+BACJnC,IACAmC,2BAAgClD,EAAhC,UAEJkD,UAAepD,EAAKkD,MAApB,6BACKlD,EAAKsB,KADV,+BAKR,0DACK8B,EADL,4BAlXRxD,IAAA,oBAAAvC,MAAA,SAwXsB6C,EAAIkB,GAClB,IAAIpB,EAAOjC,KAAKkF,QAAQ/C,GACT,kBAAXkB,EACArD,KAAKsF,cAAcnD,EAAIF,EAAKkD,MAAOlD,EAAKsB,MAExCnD,OAAOiD,GAAQlB,EAAIF,EAAKkD,MAAOlD,EAAKsB,SA7XhD1B,IAAA,gBAAAvC,MAAA,SA2YkB6C,EAAIF,EAAMsD,GACpB,IAAI7D,EAAQ8D,SAASC,eAAe,kBACpC/D,EAAMgE,MAAMC,QAAU,QACtBjE,EAAMkE,qBAAqB,MAAM,GAAG/C,UAAYZ,EAChDP,EAAMkE,qBAAqB,KAAK,GAAG/C,UAAY0C,KA/YvD1D,IAAA,cAAAvC,MAAA,SAqZgBuG,GACR,OAAIA,EAAQhC,QAAQ,MAAQ,EACjB2B,SAASC,eAAeI,EAAQ9B,UAAU,IAE1CyB,SAASM,uBAAuBD,EAAQ9B,UAAU,IAAI,MAzZzElC,IAAA,iBAAAvC,MAAA,WAiaQ,IAAI8B,KACepB,KAAKiB,MAAM8E,OAAO/F,KAAKqB,YAC7BW,QAAQ,SAACC,GAClBA,EAAKb,QAAQY,QAAQ,SAAC4B,GAClBxC,EAAQgB,MACJwB,QACA3B,aAIZb,EAAQ4E,KAAK,SAAUC,EAAGC,GACtB,OAAOA,EAAEtC,MAAMlD,OAASuF,EAAErC,MAAMlD,SAEpCV,KAAKoB,QAAUA,KA9avBS,IAAA,kBAAAvC,MAAA,SAoboBmE,GAAK,IAAA0C,EAAAnG,KACjB,OAAOyD,EAAIuC,KAAK,SAACC,EAAGC,GAChB,OAAOC,EAAKjB,QAAQe,GAAGd,MAAMiB,cAAcD,EAAKjB,QAAQgB,GAAGf,YAtbvEtD,IAAA,YAAAvC,MAAA,WA6bgB,IAAA+G,EAAArG,KAEJiB,EAAQqF,aAAaC,QAAQ,mBAAqBvG,KAAKa,UACvDI,GAASA,EAAMP,OAAS,IACxBV,KAAKiB,MAAQuF,KAAKC,MAAMxF,GACxBjB,KAAKqC,kBAGTrC,KAAK0G,WAAWC,KACZ,SAACC,GACGP,EAAKpF,MAAQuF,KAAKC,MAAMG,GAAUC,KAClCP,aAAaQ,QAAQ,mBAAqBT,EAAKxF,SAAU2F,KAAKO,UAAUV,EAAKpF,QAC7EoF,EAAKhE,iBACLgE,EAAKlF,SAAU,EACfkF,EAAKW,mBA3crBnF,IAAA,WAAAvC,MAAA,WAodQ,GAAIU,KAAKiB,MAAMP,OAAS,IAAMV,KAAKc,iBAAmBd,KAAKmB,SACvD,OAAO,EAFG,QAAA8F,EAAAxG,UAAAC,OAANwG,EAAMC,MAAAF,GAAAG,EAAA,EAAAA,EAAAH,EAAAG,IAANF,EAAME,GAAA3G,UAAA2G,GAIdpH,KAAKqH,UAAUH,MAvdvBrF,IAAA,YAAAvC,MAAA,WA6duB,QAAAgI,EAAA7G,UAAAC,OAANwG,EAAMC,MAAAG,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAANL,EAAMK,GAAA9G,UAAA8G,GACf,IAAIlE,EAAS6D,EAAK,GAAGM,QACrBxH,KAAKkB,UAAUkB,MACXiB,OAAQA,EACR6D,KAAMA,EAAK,QAjevBrF,IAAA,cAAAvC,MAAA,WAwekB,IAAAmI,EAAAzH,KACVA,KAAKkB,UAAUc,QACX,SAAC0F,GACGD,EAAKC,EAAKrE,QAAVsE,MAAAF,wHAAAG,CAAqBF,EAAKR,SAGlClH,KAAKkB,gBA9ebW,IAAA,WAAAvC,MAAA,WAofe,IAAAuI,EAAA7H,KACP,OAAO,IAAI8H,QAAQ,SAACC,EAASC,GACzB,IAAIC,EAAMJ,EAAK9G,IAAImD,QAAQ,aAAc2D,EAAKhH,UAC1CqH,EAAM,IAAIC,eACdD,EAAIE,KAAK,MAAOH,GAChBC,EAAIG,OAAS,WACU,MAAfH,EAAII,OACJP,EAAQG,EAAItB,UAEZoB,EAAO,IAAIO,MAAML,EAAIM,cAI7BN,EAAIO,QAAU,WACVT,EAAO,IAAIO,MAAM,mBAGrBL,EAAIQ,YArgBhB7G,IAAA,gBAAAvC,MAAA,WA6gBQ,IAAIqJ,EAAUnD,SAASoD,cAAc,OAyBrC,OAxBAD,EAAQE,aAAa,KAAM,kBAC3BF,EAAQE,aAAa,QAAS,SAC9BF,EAAQ9F,UAAR,qKAOa2C,SAASI,qBAAqB,QAAQ,GAC5CkD,YAAYH,GACRnD,SAASM,uBAAuB,SAAS,GAG/CiD,QAAU,WACXJ,EAAQjD,MAAMC,QAAU,QAI5BvF,OAAO2I,QAAU,SAAUC,GACC,mBAApBA,EAAMlG,OAAOX,KACbwG,EAAQjD,MAAMC,QAAU,SAGzBgD,MAtiBfpI,EAAA","file":"enlighten.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\r\n} catch (e) {\r\n\t// This works if the window reference is available\r\n\tif (typeof window === \"object\") g = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n","/**\n * @author       Niklas Berg <niklas@makeequal.se>\n * @copyright    2018 Niklas Berg\n * @license      {@link https://github.com/nkholski/enlighten/blob/license.txt|MIT License}\n *\n * A library for parsing text with word explainations, indicies and word lists.\n * Link: https://github.com/nkholski/enlighten\n * \n */\n\n\n/* TODO \n   1. Index and word list with all words.\n   2. Test match: word, *word, word*\n   3. Implement custom words\n*/\n\nglobal.Enlighten = class {\n    /**\n     * Constructor\n     *\n     * @param {language: string, useLocalStorage: bool, api: string} config \n     *                      - A configuration object. supported keys:\n     *                          language {string} - Supported by Make Equal Enlighten: \"sv\" or \"en\" (default is \"en\")\n     *                          useLocalStorage - Boolean weather to use local storage or not (default is true)\n     *                          api - url to use. Default is to use Make Equal Enlighten on analytics.makeequal.se\n     *\n     * @return {number[]}   - Array of word ids\n     */\n    constructor(config = {}) {\n        // Config\n        this.language = config.hasOwnProperty(\"language\") ? config.language : \"en\";\n        this.useLocalStorage = config.hasOwnProperty(\"useLocalStorage\") ? config.useLocalStorage : true;\n        this.api = config.hasOwnProperty(\"api\") ? config.api : \"https://analytics.makeequal.se/api/words/{language}\";\n        this.exclude = [];\n        this.words = [];\n        this.quedTasks = [];\n        this.updated = false;\n        this.matches = [];\n        // Extra words - Not implemented\n        this.extraWords = [];\n        this._getWords();\n        window.enlightenPopup = this._popupPassthrough.bind(this);\n        // Append modal popup\n        this.modal = this._addModalHTML();\n    }\n\n\n    /**\n     * Configure the script\n     *\n     * @param {object} config - A configuration object. supported keys:\n     *                          language {string} - Supported by Make Equal Analytics server: \"sv\" or \"en\"\n     *                          exclude {number[]} - List of ids to ignore\n     *\n     * @return {number[]} - Array of word ids\n     */\n    config(config) {\n        Object.keys(config).forEach(\n            (key) => {\n                switch (key) {\n                    case \"language\":\n                    case \"exclude\":\n                        this[key] = config[key];\n                        break;\n                }\n            }\n        );\n    }\n\n    /**\n     * Add a word programmatically besides what's loaded via API or JSON.\n     *\n     * @param {{title: string, matches: string[], text: string }} word - A word and it's matches\n     *\n     * @return {number} - Temporary id given to the word\n     */\n    addWord(word) {\n        if (!this._isReady(\"addWord\", word)) {\n            return;\n        }\n        word.id = -this.extraWords.length - 1; // Ids from -1 and below as opposite of fetched words that are positive.\n        this.extraWords.push(word);\n        this._updateMatches();\n    }\n\n\n    /**\n     * Get a word from id\n     *\n     * @param {number} id - Id for word to find\n     *\n     * @return {{id: number, word: string, text: string}}\n     */\n    getWord(id) {\n        if (id < 0) {\n            return this.extraWords.find((el) => {\n                return el.id === id;\n            });\n        } else {\n            return this.words.find((el) => {\n                return el.id === id;\n            });\n        }\n    }\n\n\n    /**\n     * Insert a word list\n     *\n     * @param {string} sourceRef - Class name or id of element containing source text to build word list from. Make a word list with all avaliable words by passing null\n     * @param {string} targetRef - Class name or id of element to insert the generated word list in. Set it to same element as source by passing null.\n     * @param {bool} append - Insert the word list after preexisting content of the target (default, true), or relace it (false).\n     * \n     * @return {void}\n     */\n    insertWordlist(sourceRef = \"\", targetRef = null, append = true) {\n        if (!this._isReady(\"insertWordlist\", sourceRef, targetRef, append)) {\n            return;\n        }\n        targetRef = targetRef ? targetRef : sourceRef;\n        let source = sourceRef.length > 0 ? this._getElement(sourceRef).innerHTML : \"\";\n        let target = this._getElement(targetRef);\n        let list = this._makeWordList(source);\n        if (append) {\n            target.innerHTML += list;\n        } else {\n            target.innerHTML = list;\n        }\n    }\n\n    /**\n     * Insert an index\n     *\n     * @param {string} sourceRef - Class name or id of element containing source text to build word list from. Make a word list with all avaliable words by passing null\n     * @param {string} targetRef - Class name or id of element to insert the generated word list in. Set it to same element as source by passing null.\n     * @param {bool} prepend - Insert the word list before preexisting content of the target (default, true), or relace it (false).\n     * @param {bool} linked - Make anchor tags with hrefs matching corresponding anchor names in word list (default, true), or make it plain text (false)\n     * \n     * @return {void}\n     */\n    insertIndex(sourceRef, targetRef, prepend = true, linked = true) {\n        if (!this._isReady(\"insertIndex\", sourceRef, targetRef, prepend, linked)) {\n            return;\n        }\n        targetRef = targetRef ? targetRef : sourceRef;\n        let source = sourceRef.length > 0 ? this._getElement(sourceRef).innerHTML : \"\";\n        let target = this._getElement(targetRef);\n        let list = this._makeIndex(source, linked);\n        if (prepend) {\n            target.innerHTML = list + target.innerHTML;\n        } else {\n            target.innerHTML = list;\n        }\n    }\n\n    /**\n     * Parse an element by making identified words clickable\n     *\n     * @param {string} sourceRef - Class name or id of element to parse\n     * @param {bool} multiple - Parse all occurances (default, true) or only first occurance (false)\n     * @param {string} method - Function to call when clicked. Set to null for default popup, \"index\" for linking it to a matching word list or name of custom method.\n     * \n     * @return {void}\n     */\n    parseElement(sourceRef, multiple = true, method = null) {\n        if (!this._isReady(\"parseElement\", sourceRef, multiple, method)) {\n            return;\n        }\n        let source = this._getElement(sourceRef);\n        source.innerHTML = this.parseText(source.innerHTML, multiple, method);\n    }\n\n    /**\n     * Get a list of word ids from a text (html-tags allowed)\n     *\n     * @param {string} text - Text to parse\n     * @param {bool} multiple - Weather to make all matches clickable or just first match\n     * @param {function} method - Method to call on click if not default (id, word and explaination will be passed to the method)\n     *                            Pass \"index\" to link the word to a wordlist on the same page instead of popup (or other custom solution)\n     *\n     * @return {string} - Parsed text\n     */\n    parseText(text, multiple = true, method = \"_defaultPopup\") {\n        let ids = this._getIdsFromText(text);\n        let found = [];\n        multiple = multiple === false ? false : true; // allow passing null\n        //text = text.toLowerCase();\n        method = method === null ? \"_defaultPopup\" : method; // Delayed call makes default not working...\n        this.matches.forEach(\n            (match) => {\n                if (ids.indexOf(match.word.id) === -1) {\n                    return;\n                }\n                let cleanStart = match.match.substring(0, 1) !== \"*\";\n                let cleanEnd = match.match.substring(match.match.length-1) !== \"*\";\n                let compare = match.match.replace(/\\*/g, \"\");\n                let pattern = \"<a.*?>.*?<\\/a>\" + // Not within achors\n                    \"|<en-ignore\\\\b[^>]*>.*?<\\/en-ignore>\" + // Not within ignore\n                    \"|\" + compare + \"*.?\\>\" + // Not inside tags\n                    \"|([a-zåäö]*\" + compare + \"[a-zA-ZåäöÅÄÖ]*)\"; // But match this\n\n                let rx = new RegExp(pattern, \"ig\"); // + (multiple ? \"g\" : \"\"));\n\n\n                if (rx.test(text)) {\n                    text = text.replace(rx, function (matchedWord, p1) {\n                        if(!multiple && found.indexOf(match.word.id) !== -1) {\n                            return matchedWord;\n                        }\n                        // Only match words which begins with match\n                        /*if (pos !== 0) {\n                            if ((/[a-z]/).test(text.substr(pos - 1, 1))) {\n                                return matchedWord;\n                            }\n                        }\n                        // Only match words which ends with match\n                        if (pos + matchedWord.length < text.length && (/[a-z]/).test(text.substr(pos + matchedWord.length, 1))) {\n                            return matchedWord;\n                        }*/\n                        // Only find words starting with the matcher\n                        if (cleanStart && matchedWord.toLowerCase().indexOf(compare) !== 0) {\n                            return matchedWord;\n                        }\n                        // Only find words ending with the matcher\n                        if (cleanEnd && matchedWord.toLowerCase().indexOf(compare) !== matchedWord.length - compare.length) {\n                            return matchedWord;\n                        }\n                        found.push(match.word.id);\n\n                        if (method === \"index\") {\n                            return p1 ? \"<a href='#ENLIGHT_WORD\" + match.word.id + \"' class='enlighten-clickable'>\" + p1 + \"</a>\" : matchedWord;\n                        } else {\n                            return p1 ? \"<a onClick='enlightenPopup(\" + match.word.id + \",\\\"\" + method + \"\\\")' class='enlighten-clickable'>\" + p1 + \"</a>\" : matchedWord;\n                        }\n                    });\n                }\n\n\n\n\n            }\n        );\n        text = text.replace(/<enlighten\\ data-word\\=[\\'\\\"](.*?)[\\'\\\"]\\>(.*?)<\\/enlighten>/gi, (fullMatch, keyWord, show) => {\n            let found = false;\n            let wordObject;\n            // DRY - FAIL\n            this.matches.forEach(\n                (match) => {\n                    if (found) {\n                        return;\n                    }\n                    if (match.match === keyWord.toLowerCase()) {\n                        wordObject = match;\n                        found = true;\n                        return;\n                    }\n                });\n            if (!found) {\n                return fullMatch;\n            }\n            if (method === \"index\") {\n                return keyWord ? \"<a href='#ENLIGHT_WORD\" + wordObject.word.id + \"' class='enlighten-clickable'>\" + show + \"</a>\" : fullMatch;\n            } else {\n                return keyWord ? \"<a onClick='enlightenPopup(\" + wordObject.word.id + \",\\\"\" + method + \"\\\")' class='enlighten-clickable'>\" + show + \"</a>\" : fullMatch;\n            }\n\n        });\n\n        /* TO DELETE: Without sorting\n        ids.forEach(\n            (id) => {\n                let word = this.getWord(id);\n                let matched = false;\n                word.matches.forEach(\n                    (match) => {\n                        if (matched) {\n                            return;\n                        }\n                        let rx = new RegExp(\"(?<!\\\"|>)(\\ |^)(\" + match + \".*?)(?=\\\\s|$)\", \"i\" + (multiple ? \"g\" : \"\"));\n                        if (rx.test(text)) {\n                            matched = true;\n                            if (method === \"index\") {\n                                text = text.replace(rx, \"$1<a href='#ENLIGHT_WORD\" + id + \"' class='enlighten-clickable'>$2</a>\");\n                            } else {\n                                text = text.replace(rx, \"$1<a onClick='enlightenPopup(\" + id + \",\\\"\" + method + \"\\\")' class='enlighten-clickable'>$2</a>\");\n                            }\n                            return;\n                        }\n                    });\n            }\n        );*/\n        return text;\n    }\n\n\n    /**\n     * Get a list of word ids from a text (html-tags allowed)\n     *\n     * @param {string} text - Text to build array from\n     *\n     * @return {number[]} - Array of word ids\n     */\n\n    _getIdsFromText(text = \"\") {\n        let ids = [];\n        let rx;\n        text = text.replace(/<en\\-ignore\\>.*?<\\/en-ignore>/gi, \"\");\n        text = text.replace(/<enlighten (.*?)>.*?<\\/enlighten>/gi, \"$1\");\n        text = text.replace(/<.*?>/gi, \"\");\n\n        this.matches.forEach((match) => {\n            if (ids.indexOf(match.word.id) !== -1 || this.exclude.indexOf(match.word.id) !== -1) {\n                return;\n            }\n            if (text.length === 0) { // Get entire word list if the text is null\n                ids.push(match.word.id);\n                return;\n            }\n            let cleanStart = match.match.substring(0, 1) !== \"*\";\n            let cleanEnd = match.match.substring(match.match.length-1) !== \"*\";\n            let compare = match.match.replace(/\\*/g, \"\");\n\n            let pattern = cleanStart ? \"(^|[^a-zåäöÅÄÖ])\" : \"\";\n            pattern += compare;\n            pattern += cleanEnd ? \"($|[^a-zåäöÅÄÖ])\" : \"\";\n            rx = new RegExp(pattern, \"i\");\n            if (rx.test(text)) {\n                ids.push(match.word.id);\n            }\n\n        });\n        return ids;\n    }\n\n    /**\n     * Generate a index\n     *\n     * @param {string} text - Text to build from\n     * @param {bool} linked - Should it add a anchor to the word?\n     *\n     * @return {text} - Generated html\n     */\n    _makeIndex(text, linked = true) {\n        let ids = this._alphabetizeIds(this._getIdsFromText(text));\n        let bullets = \"\";\n        ids.forEach(\n            (id) => {\n                if (linked) {\n                    bullets += `<li><a href=\"#ENLIGHT_WORD${id}\">${this.getWord(id).title}</a></li>\\n`;\n                } else {\n                    bullets += `<li>${this.getWord(id).title}</li>\\n`;\n                }\n            }\n        );\n        return `\n      <div class=\"enlighten-index\">\n        <ol>\n          ${bullets}\n        </ol>\n      </div>\n    `;\n    }\n\n    /**\n     * Generate a word list\n     *\n     * @param {string} text - Text to build from\n     * @param {bool} linked - Let the index find the words?\n     *\n     * @return {text} - Generated html\n     */\n    _makeWordList(text = \"\", linked = true) {\n        let ids = this._alphabetizeIds(this._getIdsFromText(text));\n        let html = \"\";\n        ids.forEach(\n            (id) => {\n                let word = this.getWord(id);\n                html += '<div class=\"enlighten-word\">';\n                if (linked) {\n                    html += `<a name=\"ENLIGHT_WORD${id}\"></a>`;\n                }\n                html += `<h3>${word.title}</h3>\n             <span>${word.text}</span>\n           </div>`;\n            }\n        );\n        return `<div class=\"enlighten-word-explainations\">\n           ${html}\n       </div>\n     `;\n    }\n\n    _popupPassthrough(id, method) {\n        let word = this.getWord(id);\n        if (method === \"_defaultPopup\") {\n            this._defaultPopup(id, word.title, word.text);\n        } else {\n            window[method](id, word.title, word.text);\n        }\n\n    }\n\n    /**\n     * Default popup fuction\n     *\n     * @param {number} id - Id of the word\n     * @param {string} word - The word to show\n     * @param {string} explaination - The explaination\n     *\n     * @return null\n     */\n    _defaultPopup(id, word, explaination) {\n        let modal = document.getElementById(\"enlightenModal\");\n        modal.style.display = \"block\";\n        modal.getElementsByTagName(\"h3\")[0].innerHTML = word;\n        modal.getElementsByTagName(\"p\")[0].innerHTML = explaination;\n    }\n\n    /** \n     * Get an element based by id or class name (instead of using jQuery ;-D)\n     */\n    _getElement(element) {\n        if (element.indexOf(\"#\") > -1) {\n            return document.getElementById(element.substring(1));\n        } else {\n            return document.getElementsByClassName(element.substring(1))[0];\n        }\n    }\n\n    /** \n     * Update list of matches\n     */\n    _updateMatches() {\n        let matches = [];\n        let completeList = this.words.concat(this.extraWords);\n        completeList.forEach((word) => {\n            word.matches.forEach((match) => {\n                matches.push({\n                    match,\n                    word\n                });\n            });\n        });\n        matches.sort(function (a, b) {\n            return b.match.length - a.match.length;\n        });\n        this.matches = matches;\n    }\n\n    /**\n     * Alphabethic list of matches for indices and word lists\n     */\n    _alphabetizeIds(ids) {\n        return ids.sort((a, b) => {\n            return this.getWord(a).title.localeCompare(this.getWord(b).title);\n        });\n    }\n\n    /** \n     * Get words from database (or cached in localStorage)\n     */\n    _getWords() {\n        // Try to get it from localStorage\n        let words = localStorage.getItem(\"enlighten_words_\" + this.language);\n        if (words && words.length > 0) {\n            this.words = JSON.parse(words);\n            this._updateMatches();\n        }\n        // Fetch from server (even if we found something in localStorage)\n        this._ajaxGet().then(\n            (response) => {\n                this.words = JSON.parse(response).data;\n                localStorage.setItem(\"enlighten_words_\" + this.language, JSON.stringify(this.words));\n                this._updateMatches();\n                this.updated = true;\n                this._executeQue();\n            }\n        );\n    }\n\n    /** \n     * Check if Enlighten is ready to parse text (got words to use).\n     */\n    _isReady(...args) {\n        if (this.words.length > 0 && (this.useLocalStorage || this.updated)) {\n            return true;\n        }\n        this._addToQue(args);\n    }\n\n    /** \n     * Add to cue of tasks to execute when Enlighten is ready.\n     */\n    _addToQue(...args) {\n        let method = args[0].shift();\n        this.quedTasks.push({\n            method: method,\n            args: args[0]\n        });\n    }\n\n    /** \n     * Execute waiting tasks.\n     */\n    _executeQue() {\n        this.quedTasks.forEach(\n            (task) => {\n                this[task.method](...task.args);\n            }\n        );\n        this.quedTasks = [];\n    }\n\n    /** \n     * Fetch words from API or static JSON-file\n     */\n    _ajaxGet() {\n        return new Promise((resolve, reject) => {\n            let url = this.api.replace(\"{language}\", this.language);\n            let req = new XMLHttpRequest();\n            req.open(\"GET\", url);\n            req.onload = function () {\n                if (req.status === 200) {\n                    resolve(req.response);\n                } else {\n                    reject(new Error(req.statusText));\n                }\n            };\n\n            req.onerror = function () {\n                reject(new Error(\"Network error\"));\n            };\n\n            req.send();\n        });\n    }\n\n    /** \n     * Make default modal popup\n     */\n    _addModalHTML() {\n        let modalEl = document.createElement(\"div\");\n        modalEl.setAttribute(\"id\", \"enlightenModal\");\n        modalEl.setAttribute(\"class\", \"modal\");\n        modalEl.innerHTML = `\n          <div class=\"modal-content\">\n            <span class=\"close\">&times;</span>\n            <h3>Title</h3>\n            <p>Content</p>\n          </div>f`;\n\n        let bodyEl = document.getElementsByTagName('body')[0];\n        bodyEl.appendChild(modalEl);\n        let span = document.getElementsByClassName(\"close\")[0];\n\n        // When the user clicks on <span> (x), close the modal\n        span.onclick = function () {\n            modalEl.style.display = \"none\";\n        };\n\n        // When the user clicks anywhere outside of the modal, close it\n        window.onclick = function (event) {\n            if (event.target.id === \"enlightenModal\") {\n                modalEl.style.display = \"none\";\n            }\n        };\n        return modalEl;\n    }\n};\n"],"sourceRoot":""}